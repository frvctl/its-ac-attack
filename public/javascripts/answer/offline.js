// Generated by CoffeeScript 1.3.3
(function() {
  var fisher_yates, getQuestion, loadQuestions, question_schedule, questions, virtual_server;

  questions = [
    {
      "category": "Meta",
      "question_num": 666,
      "tournament": "Metaception Bowl",
      "question": "This application was intended to act as a chat client which could handle single user sessions offline by pretending the user was schizophrenic. It was started primarily because of an argument about how to implement multiplayer and whether or not the DC comics character, the Joker, might say \"Singleplayer is Multiplayer without balls\". For 10 points, name this application that you are almost certainly using right now.",
      "accept": null,
      "difficulty": "HS",
      "year": 2012,
      "answer": "protobowl",
      "round": "Round_10_HSAPQ4Q.pdf"
    }
  ];

  fisher_yates = function(i) {
    var arr, j, _i, _ref, _results;
    if (i === 0) {
      return [];
    }
    arr = (function() {
      _results = [];
      for (var _i = 0; 0 <= i ? _i < i : _i > i; 0 <= i ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this);
    while (--i) {
      j = Math.floor(Math.random() * (i + 1));
      _ref = [arr[j], arr[i]], arr[i] = _ref[0], arr[j] = _ref[1];
    }
    return arr;
  };

  question_schedule = [];

  getQuestion = function() {
    if (question_schedule.length === 0) {
      question_schedule = fisher_yates(questions.length);
    }
    return questions[question_schedule.shift()];
  };

  virtual_server = {
    pause: function() {
      if (!(sync.attempt || time() > sync.end_time)) {
        return this.freeze();
      }
    },
    unpause: function() {
      if (!sync.attempt) {
        return this.unfreeze();
      }
    },
    set_time: function(ts) {
      return sync.time_offset = serverTime() - ts;
    },
    freeze: function() {
      return sync.time_freeze = time();
    },
    unfreeze: function() {
      if (sync.time_freeze) {
        this.set_time(sync.time_freeze);
        return sync.time_freeze = 0;
      }
    },
    skip: function() {
      return this.new_question();
    },
    connect: function() {
      console.log("initializing server!");
      return loadQuestions(function() {
        return sock.server_emit("connect");
      });
    },
    init_offline: function() {
      return loadQuestions();
    },
    rename: function(name) {
      return users[public_id].name = name;
    },
    join: function(data) {
      var publicID, publicName;
      publicID = "offline";
      publicName = require('names').generateName();
      console.log("joining stuff", data);
      sync.answer_duration = 1000 * 5;
      sync.time_offset = 0;
      sync.users = [
        {
          guesses: 0,
          interrupts: 0,
          early: 0,
          correct: 0,
          last_action: 0,
          id: publicID,
          name: publicName
        }
      ];
      sync.rate = Math.round(1000 * 60 / 3 / 300);
      this.freeze();
      this.new_question();
      sock.server_emit('introduce', {
        user: publicID
      });
      setTimeout(function() {
        return synchronize();
      }, 10);
      return {
        name: publicName,
        id: publicID
      };
    },
    chat: function(msg) {
      var count, pick, reply, session, writeLetter;
      sock.server_emit('chat', {
        text: msg.text,
        session: msg.session,
        user: public_id,
        done: msg.done,
        time: serverTime()
      });
      if (msg.done) {
        if ((typeof replies !== "undefined" && replies !== null) || /lonely/.test(msg.text)) {
          session = Math.random().toString(36).slice(2);
          if (typeof replies !== "undefined" && replies !== null) {
            pick = function(list) {
              return list[Math.floor(list.length * Math.random())];
            };
            if (msg.text.replace(/[^a-z]/g, '') in replies) {
              reply = pick(replies[msg.text.replace(/[^a-z]/g, '')]) + "    ";
            } else {
              reply = pick(Object.keys(replies));
              reply = pick(replies[reply]);
            }
          } else {
            $.ajax({
              url: "../lib/chatbot.js",
              cache: true,
              dataType: "script"
            });
            reply = "I'm lonely too. Plz talk to meeeee";
          }
          count = 0;
          writeLetter = function() {
            if (++count <= reply.length) {
              sock.server_emit('chat', {
                text: reply.slice(0, count),
                session: session,
                user: public_id,
                done: count === reply.length,
                time: serverTime()
              });
              return setTimeout(writeLetter, 1000 * 60 / 6 / 130);
            }
          };
          return writeLetter();
        }
      }
    },
    new_question: function() {
      var question, syllables, word;
      sync.attempt = null;
      sync.begin_time = time();
      question = getQuestion();
      sync.info = {
        category: question.category,
        difficulty: question.difficulty,
        tournament: question.tournament,
        num: question.question_num,
        year: question.year,
        round: question.round
      };
      sync.question = question.question.replace(/FTP/g, 'For 10 points').replace(/^\[.*?\]/, '').replace(/\n/g, ' ').replace(/\s+/g, ' ');
      sync.answer = question.answer.replace(/\<\w\w\>/g, '').replace(/\[\w\w\]/g, '');
      syllables = require('..../answer/syllable').syllables;
      sync.timing = (function() {
        var _i, _len, _ref, _results;
        _ref = sync.question.split(" ");
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          word = _ref[_i];
          _results.push(syllables(word) + 1);
        }
        return _results;
      })();
      this.set_speed(sync.rate);
      return synchronize();
    },
    speed: function(rate) {
      this.set_speed(rate);
      return synchronize();
    },
    set_speed: function(rate) {
      var cumulative, done, duration, elapsed, new_duration, now, remainder;
      now = time();
      cumulative = cumsum(sync.timing, sync.rate);
      elapsed = now - sync.begin_time;
      duration = cumulative[cumulative.length - 1];
      done = elapsed / duration;
      remainder = 0;
      if (done > 1) {
        remainder = elapsed - duration;
        done = 1;
      }
      sync.rate = rate;
      cumulative = cumsum(sync.timing, sync.rate);
      new_duration = cumulative[cumulative.length - 1];
      sync.begin_time = now - new_duration * done - remainder;
      return sync.end_time = sync.begin_time + new_duration + sync.answer_duration;
    },
    guess: function(data) {
      if (sync.attempt) {
        sync.attempt.text = data.text;
        if (data.done) {
          return this.end_buzz(sync.attempt.session);
        }
      }
    },
    end_buzz: function(session) {
      var checkAnswer, _ref;
      if (((_ref = sync.attempt) != null ? _ref.session : void 0) === session) {
        sync.attempt.done = true;
        checkAnswer = require('../answer/answerparse').checkAnswer;
        sync.attempt.correct = checkAnswer(sync.attempt.text, sync.answer);
        synchronize();
        this.unfreeze();
        if (sync.attempt.correct) {
          users[public_id].correct++;
          if (sync.attempt.early) {
            users[public_id].early++;
          }
          this.set_time(sync.end_time);
        } else if (sync.attempt.interrupt) {
          users[public_id].interrupts++;
        }
        sync.attempt = null;
        return synchronize();
      }
    },
    buzz: function() {
      var cumulative, early_index, session,
        _this = this;
      if (time() <= sync.end_time) {
        session = Math.random().toString(36).slice(2);
        early_index = sync.question.replace(/[^ \*]/g, '').indexOf('*');
        cumulative = cumsum(sync.timing, sync.rate);
        sync.attempt = {
          user: public_id,
          realTime: serverTime(),
          start: time(),
          duration: 8 * 1000,
          session: session,
          text: '',
          early: early_index && time() < sync.begin_time + cumulative[early_index],
          interrupt: time() < sync.end_time - sync.answer_duration,
          done: false
        };
        users[public_id].guesses++;
        this.freeze();
        return this.timeout(serverTime, sync.attempt.realTime + sync.attempt.duration, function() {
          return _this.end_buzz(session);
        });
      }
    },
    timeout: function(metric, time, callback) {
      var diff,
        _this = this;
      diff = time - metric();
      if (diff < 0) {
        return callback();
      } else {
        return setTimeout(function() {
          return _this.timeout(metric, time, callback);
        }, diff);
      }
    }
  };

  loadQuestions = function(fn) {
    return $.ajax('questions.txt').done(function(text) {
      var line;
      questions = (function() {
        var _i, _len, _ref, _results;
        _ref = text.split('\n');
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          line = _ref[_i];
          _results.push(JSON.parse(line));
        }
        return _results;
      })();
      console.log('got questions', questions.length);
      if (fn) {
        return fn();
      }
    });
  };

  if (!(typeof io !== "undefined" && io !== null)) {
    virtual_server.connect();
  }

}).call(this);
